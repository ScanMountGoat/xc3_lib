use std::path::{Path, PathBuf};

use anyhow::Context;
use clap::Parser;
use xc3_model::{
    animation::Animation,
    gltf::{GlbFile, GltfFile},
    load_animations, load_model, load_model_legacy,
    shader_database::ShaderDatabase,
    MapRoot, ModelRoot,
};

/// Convert wimdo and wismhd models to glTF or glb for
/// Xenoblade X, Xenoblade 1 DE, Xenoblade 2, and Xenoblade 3.
#[derive(Parser)]
#[command(author, version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    // TODO: Multiple paths
    /// The input wimdo, pcmdo, camdo, or wismhd file.
    input: String,
    /// The output gltf or glb file.
    /// Defaults to input as a glb if not specified.
    /// Images will be saved to the same directory as the output for gltf.
    output: Option<String>,
    /// The shader database generated by xc3_shader.
    /// Defaults to "xc_combined.bin" if not specified.
    #[arg(long)]
    database: Option<String>,
    // TODO: Multiple animations
    /// The mot animation file.
    #[arg(long)]
    anim: Option<String>,
}

fn database_path() -> std::io::Result<PathBuf> {
    Ok(std::env::current_exe()?
        .parent()
        .unwrap_or(Path::new(""))
        .join("xc_combined.bin"))
}

fn main() -> anyhow::Result<()> {
    simple_logger::SimpleLogger::new()
        .with_level(log::LevelFilter::Warn)
        .init()
        .unwrap();

    let cli = Cli::parse();

    let start = std::time::Instant::now();

    let database = match cli.database {
        Some(p) => Some(ShaderDatabase::from_file(&p).with_context(|| format!("{p:?}"))?),
        None => ShaderDatabase::from_file(database_path()?).ok(),
    };

    let input = Path::new(&cli.input);
    // Default to glb since it produces only a single file.
    let output = cli
        .output
        .map(PathBuf::from)
        .unwrap_or(input.with_extension("glb"));

    let name = output.file_stem().unwrap().to_string_lossy().to_string();

    let is_glb = output.extension().and_then(|e| e.to_str()) == Some("glb");

    let animations = cli
        .anim
        .map(load_animations)
        .transpose()
        .with_context(|| "failed to load animations")?
        .unwrap_or_default();

    if let Some(parent) = output.parent() {
        std::fs::create_dir_all(parent)
            .with_context(|| format!("failed to create output directory {parent:?}"))?;
    }

    match input.extension().unwrap().to_str().unwrap() {
        "wimdo" => {
            let root = load_model(&cli.input, database.as_ref())
                .with_context(|| format!("failed to load .wimdo model {:?}", cli.input))?;
            if is_glb {
                export_model_glb(root, animations, &name, &output, false)
            } else {
                export_model_gltf(root, animations, &name, &output, false)
            }
        }
        "pcmdo" => {
            let root = load_model(&cli.input, database.as_ref())
                .with_context(|| format!("failed to load .pcmdo model {:?}", cli.input))?;
            if is_glb {
                export_model_glb(root, animations, &name, &output, false)
            } else {
                export_model_gltf(root, animations, &name, &output, false)
            }
        }
        "camdo" => {
            let root = load_model_legacy(&cli.input, database.as_ref())
                .with_context(|| format!("failed to load .camdo model {:?}", cli.input))?;
            if is_glb {
                export_model_glb(root, animations, &name, &output, true)
            } else {
                export_model_gltf(root, animations, &name, &output, true)
            }
        }
        "wismhd" => {
            let roots = xc3_model::load_map(&cli.input, database.as_ref())
                .with_context(|| format!("failed to load .wismhd map {:?}", cli.input))?;
            if is_glb {
                export_map_glb(roots, &name, &output, false)
            } else {
                export_map_gltf(roots, &name, &output, false)
            }
        }
        e => Err(anyhow::anyhow!("unsupported extension {e}")),
    }?;

    println!("Converted in {:?}", start.elapsed());
    Ok(())
}

fn export_map_gltf(
    roots: Vec<MapRoot>,
    name: &str,
    output: &Path,
    flip_images_uvs: bool,
) -> anyhow::Result<()> {
    GltfFile::from_map(name, &roots, flip_images_uvs)
        .with_context(|| "failed to create glTF file")?
        .save(output)
        .with_context(|| format!("failed to save glTF file to {:?}", output))
}

fn export_map_glb(
    roots: Vec<MapRoot>,
    name: &str,
    output: &Path,
    flip_images_uvs: bool,
) -> anyhow::Result<()> {
    GlbFile::from_map(name, &roots, flip_images_uvs)
        .with_context(|| "failed to create glb file")?
        .save(output)
        .with_context(|| format!("failed to save glb file to {:?}", output))
}

fn export_model_gltf(
    root: ModelRoot,
    animations: Vec<Animation>,
    name: &str,
    output: &Path,
    flip_images_uvs: bool,
) -> anyhow::Result<()> {
    GltfFile::from_model(name, &[root], &animations, flip_images_uvs)
        .with_context(|| "failed to create glTF file")?
        .save(output)
        .with_context(|| format!("failed to save glTF file to {:?}", output))
}

fn export_model_glb(
    root: ModelRoot,
    animations: Vec<Animation>,
    name: &str,
    output: &Path,
    flip_images_uvs: bool,
) -> anyhow::Result<()> {
    GlbFile::from_model(name, &[root], &animations, flip_images_uvs)
        .with_context(|| "failed to create glb file")?
        .save(output)
        .with_context(|| format!("failed to save glb file to {:?}", output))
}
