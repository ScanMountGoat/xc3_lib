use std::path::Path;

use anyhow::Context;
use clap::Parser;
use xc3_model::{
    animation::Animation,
    gltf::{GlbFile, GltfFile},
    load_animations, load_model, load_model_legacy,
    shader_database::ShaderDatabase,
    MapRoot, ModelRoot,
};

/// Convert wimdo and wismhd models to glTF or glb for
/// Xenoblade X, Xenoblade 1 DE, Xenoblade 2, and Xenoblade 3.
#[derive(Parser)]
#[command(author, version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    // TODO: Multiple paths
    /// The input wimdo, pcmdo, camdo, or wismhd file.
    input: String,
    /// The output gltf or glb file.
    /// Images will be saved to the same directory as the output for gltf.
    output: String,
    // TODO: arg(long)?
    /// The shader database generated by xc3_shader.
    database: Option<String>,
    // TODO: This should be a list?
    /// The mot animation file.
    animation: Option<String>,
}

fn main() -> anyhow::Result<()> {
    simple_logger::SimpleLogger::new()
        .with_level(log::LevelFilter::Warn)
        .init()
        .unwrap();

    let cli = Cli::parse();

    let start = std::time::Instant::now();

    let database = cli
        .database
        .map(|p| ShaderDatabase::from_file(&p).with_context(|| format!("{p:?}")))
        .transpose()?;

    let output = Path::new(&cli.output);

    let name = output.file_stem().unwrap().to_string_lossy().to_string();

    let is_glb = output.extension().and_then(|e| e.to_str()) == Some("glb");

    let animations = cli
        .animation
        .map(|path| load_animations(path))
        .transpose()
        .with_context(|| "failed to load animations")?
        .unwrap_or_default();

    if let Some(parent) = output.parent() {
        std::fs::create_dir_all(parent)
            .with_context(|| format!("failed to create output directory {parent:?}"))?;
    }

    match Path::new(&cli.input).extension().unwrap().to_str().unwrap() {
        "wimdo" => {
            let root = load_model(&cli.input, database.as_ref())
                .with_context(|| format!("failed to load .wimdo model {:?}", cli.input))?;
            if is_glb {
                export_model_glb(root, animations, &name, output, false)
            } else {
                export_model_gltf(root, animations, &name, output, false)
            }
        }
        "pcmdo" => {
            let root = load_model(&cli.input, database.as_ref())
                .with_context(|| format!("failed to load .pcmdo model {:?}", cli.input))?;
            if is_glb {
                export_model_glb(root, animations, &name, output, false)
            } else {
                export_model_gltf(root, animations, &name, output, false)
            }
        }
        "camdo" => {
            let root = load_model_legacy(&cli.input, database.as_ref())
                .with_context(|| format!("failed to load .camdo model {:?}", cli.input))?;
            if is_glb {
                export_model_glb(root, animations, &name, output, true)
            } else {
                export_model_gltf(root, animations, &name, output, true)
            }
        }
        "wismhd" => {
            let roots = xc3_model::load_map(&cli.input, database.as_ref())
                .with_context(|| format!("failed to load .wismhd map {:?}", cli.input))?;
            if is_glb {
                export_map_glb(roots, &name, output, false)
            } else {
                export_map_gltf(roots, &name, output, false)
            }
        }
        e => Err(anyhow::anyhow!("unsupported extension {e}")),
    }?;

    println!("Converted in {:?}", start.elapsed());
    Ok(())
}

fn export_map_gltf(
    roots: Vec<MapRoot>,
    name: &str,
    output: &Path,
    flip_images_uvs: bool,
) -> anyhow::Result<()> {
    GltfFile::from_map(name, &roots, flip_images_uvs)
        .with_context(|| "failed to create glTF file")?
        .save(output)
        .with_context(|| format!("failed to save glTF file to {:?}", output))
}

fn export_map_glb(
    roots: Vec<MapRoot>,
    name: &str,
    output: &Path,
    flip_images_uvs: bool,
) -> anyhow::Result<()> {
    GlbFile::from_map(name, &roots, flip_images_uvs)
        .with_context(|| "failed to create glb file")?
        .save(output)
        .with_context(|| format!("failed to save glb file to {:?}", output))
}

fn export_model_gltf(
    root: ModelRoot,
    animations: Vec<Animation>,
    name: &str,
    output: &Path,
    flip_images_uvs: bool,
) -> anyhow::Result<()> {
    GltfFile::from_model(name, &[root], &animations, flip_images_uvs)
        .with_context(|| "failed to create glTF file")?
        .save(output)
        .with_context(|| format!("failed to save glTF file to {:?}", output))
}

fn export_model_glb(
    root: ModelRoot,
    animations: Vec<Animation>,
    name: &str,
    output: &Path,
    flip_images_uvs: bool,
) -> anyhow::Result<()> {
    GlbFile::from_model(name, &[root], &animations, flip_images_uvs)
        .with_context(|| "failed to create glb file")?
        .save(output)
        .with_context(|| format!("failed to save glb file to {:?}", output))
}
