use std::path::{Path, PathBuf};

use anyhow::Context;
use clap::Parser;
use xc3_model::{
    MapRoot, ModelRoot,
    animation::Animation,
    gltf::{GlbFile, GltfFile},
    load_animations, load_model, load_model_legacy,
    monolib::ShaderTextures,
    shader_database::ShaderDatabase,
};

/// Convert wimdo, pmcdo, camdo, or wismhd models to glTF or glb for
/// Xenoblade X, Xenoblade 1 DE, Xenoblade 2, Xenoblade 3, and Xenoblade X DE.
#[derive(Parser)]
#[command(author, version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    /// The input wimdo, pcmdo, camdo, or wismhd files.
    inputs: Vec<String>,
    /// The output gltf or glb file.
    /// Defaults to the first input as a glb if not specified.
    /// Images will be saved to the same directory as the output for gltf.
    #[arg(short, long)]
    output: Option<String>,
    /// The shader database generated by xc3_shader.
    /// Defaults to "xc_combined.bin" if not specified.
    #[arg(long)]
    database: Option<String>,
    /// The mot animation files.
    #[arg(long)]
    anim: Vec<String>,
}

fn database_path() -> std::io::Result<PathBuf> {
    Ok(std::env::current_exe()?
        .parent()
        .unwrap_or(Path::new(""))
        .join("xc_combined.bin"))
}

fn main() -> anyhow::Result<()> {
    simple_logger::SimpleLogger::new()
        .with_level(log::LevelFilter::Warn)
        .init()
        .unwrap();

    let cli = Cli::parse();

    let start = std::time::Instant::now();

    // The current database won't work with single texture glTF assignments.
    // TODO: Find a way to bake textures.
    let _database = match cli.database {
        Some(p) => Some(ShaderDatabase::from_file(&p).with_context(|| format!("{p:?}"))?),
        None => ShaderDatabase::from_file(database_path()?).ok(),
    };
    let database = None;

    let first_input = Path::new(&cli.inputs[0]);

    // Default to glb since it produces only a single file.
    let output = cli
        .output
        .map(PathBuf::from)
        .unwrap_or(first_input.with_extension("glb"));

    let name = output.file_stem().unwrap().to_string_lossy().to_string();

    let is_glb = output.extension().and_then(|e| e.to_str()) == Some("glb");

    let mut animations = Vec::new();
    for anim in cli.anim {
        let anims = load_animations(anim).with_context(|| "failed to load animations")?;
        animations.extend(anims);
    }

    if let Some(parent) = output.parent() {
        std::fs::create_dir_all(parent)
            .with_context(|| format!("failed to create output directory {parent:?}"))?;
    }

    // Assume paths are somewhere in a full game dump.
    let mut root_folder = first_input;
    while let Some(parent) = root_folder.parent() {
        if root_folder.join("monolib/shader").exists() {
            break;
        } else {
            root_folder = parent;
        }
    }
    let shader_textures = ShaderTextures::from_folder(root_folder.join("monolib/shader"));

    let mut model_roots = Vec::new();
    let mut map_roots = Vec::new();

    let mut has_legacy = false;
    let mut has_modern = false;

    for input in &cli.inputs {
        match Path::new(input).extension().unwrap().to_str().unwrap() {
            "wimdo" => {
                let root = load_model(input, database.as_ref())
                    .with_context(|| format!("failed to load .wimdo model {:?}", cli.inputs))?;
                model_roots.push(root);

                has_modern = true;
            }
            "pcmdo" => {
                let root = load_model(input, database.as_ref())
                    .with_context(|| format!("failed to load .pcmdo model {:?}", cli.inputs))?;
                model_roots.push(root);

                has_modern = true;
            }
            "camdo" => {
                let root = load_model_legacy(input, database.as_ref())
                    .with_context(|| format!("failed to load .camdo model {:?}", cli.inputs))?;
                model_roots.push(root);

                has_legacy = true;
            }
            "wismhd" => {
                let roots = xc3_model::load_map(input, database.as_ref())
                    .with_context(|| format!("failed to load .wismhd map {:?}", cli.inputs))?;
                map_roots.extend(roots);

                has_modern = true;
            }
            e => return Err(anyhow::anyhow!("unsupported extension {e}")),
        }
    }

    if has_legacy && has_modern {
        return Err(anyhow::anyhow!(
            "exporting switch files together with legacy camdo files is not supported"
        ));
    }

    if !model_roots.is_empty() {
        if is_glb {
            export_model_glb(
                &model_roots,
                animations,
                &name,
                &output,
                &shader_textures,
                has_legacy,
            )?;
        } else {
            export_model_gltf(
                &model_roots,
                animations,
                &name,
                &output,
                &shader_textures,
                has_legacy,
            )?;
        }
    } else if !map_roots.is_empty() {
        if is_glb {
            export_map_glb(&map_roots, &name, &output, &shader_textures, has_legacy)?;
        } else {
            export_map_gltf(&map_roots, &name, &output, &shader_textures, has_legacy)?;
        }
    } else if !model_roots.is_empty() && !map_roots.is_empty() {
        return Err(anyhow::anyhow!(
            "exporting both models and maps is not supported"
        ));
    }

    println!("Converted in {:?}", start.elapsed());
    Ok(())
}

fn export_map_gltf(
    roots: &[MapRoot],
    name: &str,
    output: &Path,
    shader_textures: &ShaderTextures,
    flip_images_uvs: bool,
) -> anyhow::Result<()> {
    GltfFile::from_map(name, roots, shader_textures, flip_images_uvs)
        .with_context(|| "failed to create glTF file")?
        .save(output)
        .with_context(|| format!("failed to save glTF file to {output:?}"))
}

fn export_map_glb(
    roots: &[MapRoot],
    name: &str,
    output: &Path,
    shader_textures: &ShaderTextures,
    flip_images_uvs: bool,
) -> anyhow::Result<()> {
    GlbFile::from_map(name, roots, shader_textures, flip_images_uvs)
        .with_context(|| "failed to create glb file")?
        .save(output)
        .with_context(|| format!("failed to save glb file to {output:?}"))
}

fn export_model_gltf(
    roots: &[ModelRoot],
    animations: Vec<Animation>,
    name: &str,
    output: &Path,
    shader_textures: &ShaderTextures,
    flip_images_uvs: bool,
) -> anyhow::Result<()> {
    GltfFile::from_model(name, roots, &animations, shader_textures, flip_images_uvs)
        .with_context(|| "failed to create glTF file")?
        .save(output)
        .with_context(|| format!("failed to save glTF file to {output:?}"))
}

fn export_model_glb(
    roots: &[ModelRoot],
    animations: Vec<Animation>,
    name: &str,
    output: &Path,
    shader_textures: &ShaderTextures,
    flip_images_uvs: bool,
) -> anyhow::Result<()> {
    GlbFile::from_model(name, roots, &animations, shader_textures, flip_images_uvs)
        .with_context(|| "failed to create glb file")?
        .save(output)
        .with_context(|| format!("failed to save glb file to {output:?}"))
}
